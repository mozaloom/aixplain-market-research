#!/usr/bin/env python3
"""
FastAPI backend for Market Research React UI
"""
from mangum import Mangum
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
from pydantic import BaseModel
import importlib
import markdown
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib.colors import HexColor
from datetime import datetime
import tempfile
import os
import re

app = FastAPI(title="Market Research API")
handler = Mangum(app, lifespan="off")

app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000",  # Local development
        "https://*.amplifyapp.com",  # AWS Amplify domains
        "https://*.amazonaws.com",  # AWS domains
        "https://*.cloudfront.net",  # CloudFront domains
        "https://main.d1lnp7miiwrzlm.amplifyapp.com",  # Production frontend
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Global cache for agents to avoid recreating them
agent_cache = {}
cache_expiry = {}
CACHE_DURATION = 3600  # 1 hour in seconds

def get_cached_system(script_name: str, api_key: str):
    """Get or create a cached market research system"""
    import time
    current_time = time.time()
    cache_key = f"{script_name}_{hash(api_key)}"
    
    # Check if we have a valid cached system
    if (cache_key in agent_cache and 
        cache_key in cache_expiry and 
        current_time < cache_expiry[cache_key]):
        print(f"🔄 Using cached agents for {script_name}")
        return agent_cache[cache_key]
    
    # Create new system and cache it
    print(f"🆕 Creating new agents for {script_name}")
    module = importlib.import_module(script_name)
    MarketResearchSystem = module.MarketResearchSystem
    
    system = MarketResearchSystem(api_key)
    
    # Setup agents
    if script_name == "market_research_advanced":
        setup_success = system.setup_agents()
        if not setup_success:
            raise HTTPException(status_code=500, detail="Failed to setup agents")
    else:
        system.setup_agents()
    
    # Cache the system
    agent_cache[cache_key] = system
    cache_expiry[cache_key] = current_time + CACHE_DURATION
    
    return system

def clear_expired_cache():
    """Clear expired cache entries"""
    import time
    current_time = time.time()
    expired_keys = [key for key, expiry in cache_expiry.items() if current_time >= expiry]
    for key in expired_keys:
        if key in agent_cache:
            del agent_cache[key]
        del cache_expiry[key]
    if expired_keys:
        print(f"🧹 Cleared {len(expired_keys)} expired cache entries")

class AnalysisRequest(BaseModel):
    product: str
    industry: str = "Technology"
    depth: str = "detailed"
    script: str = "market_research_advanced"
    apiKey: str

class DownloadRequest(BaseModel):
    product: str
    results: dict

def extract_clean_markdown(raw_content):
    """Extract clean markdown content from agent response"""
    if not raw_content:
        return "No analysis content available."
    
    content_str = str(raw_content)
    
    # Pattern 1: Look for markdown content between markers
    patterns = [
        # Look for executive summary pattern
        r"(# [^#]*Market Research Analysis.*?)(?=Generated by|session_id|critiques=|$)",
        # Look for AWS analysis pattern specifically  
        r"(# AWS Market Research Analysis.*?)(?=Generated by|session_id|critiques=|$)",
        # Look for any structured markdown
        r"(## Executive Summary.*?)(?=Generated by|session_id|critiques=|$)",
        # Extract from output field
        r"output[=:]'([^']*(?:''[^']*)*)'",
        r'output[=:]"([^"]*(?:""[^"]*)*)"',
    ]
    
    for pattern in patterns:
        match = re.search(pattern, content_str, re.DOTALL | re.IGNORECASE)
        if match:
            extracted = match.group(1) if len(match.groups()) > 0 else match.group(0)
            # Clean up the extracted content
            cleaned = clean_extracted_content(extracted)
            if len(cleaned) > 100 and ('Analysis' in cleaned or 'Summary' in cleaned):
                return cleaned
    
    # Fallback: try to find any structured content
    if '##' in content_str or '###' in content_str:
        # Find first markdown header and extract content
        lines = content_str.split('\n')
        start_idx = -1
        for i, line in enumerate(lines):
            if line.strip().startswith('#') and ('Analysis' in line or 'Summary' in line or 'AWS' in line):
                start_idx = i
                break
        
        if start_idx != -1:
            # Extract content from this point until we hit noise
            end_markers = ['Generated by', 'session_id', 'critiques=', 'execution_stats', 'api_call_breakdown']
            end_idx = len(lines)
            for i, line in enumerate(lines[start_idx:], start_idx):
                for marker in end_markers:
                    if marker.lower() in line.lower():
                        end_idx = i
                        break
                if end_idx != len(lines):
                    break
            
            extracted_lines = lines[start_idx:end_idx]
            cleaned_content = '\n'.join(extracted_lines).strip()
            if len(cleaned_content) > 100:
                return clean_extracted_content(cleaned_content)
    
    # Final fallback - return first reasonable chunk
    if len(content_str) > 200:
        return content_str[:2000] + "..."
    
    return content_str

def clean_extracted_content(content):
    """Clean up extracted markdown content"""
    # Remove escaped characters
    content = content.replace('\\n', '\n').replace('\\"', '"').replace("\\'", "'")
    content = content.replace('\\t', '\t')
    
    # Remove technical noise
    noise_patterns = [
        r'AgentResponse\([^)]+\)',
        r'status=SUCCESS',
        r'data=\'[^\']*\'',
        r'session_id[^,}]+',
        r'critiques[^,}]+',
        r'execution_stats[^}]+}',
        r'{[^}]*api_calls[^}]*}',
    ]
    
    for pattern in noise_patterns:
        content = re.sub(pattern, '', content, flags=re.IGNORECASE)
    
    # Clean up multiple newlines and spaces
    content = re.sub(r'\n\s*\n\s*\n', '\n\n', content)
    content = re.sub(r'[ \t]+', ' ', content)
    
    return content.strip()

def create_pdf_report(content, product_name, filename):
    """Create a PDF report using reportlab"""
    doc = SimpleDocTemplate(filename, pagesize=A4, 
                           rightMargin=72, leftMargin=72, 
                           topMargin=72, bottomMargin=18)
    
    # Get styles
    styles = getSampleStyleSheet()
    
    # Custom styles
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        textColor=HexColor('#2563eb'),
        alignment=1  # Center alignment
    )
    
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=16,
        spaceAfter=20,
        textColor=HexColor('#1d4ed8'),
        leftIndent=0
    )
    
    body_style = ParagraphStyle(
        'CustomBody',
        parent=styles['Normal'],
        fontSize=11,
        spaceAfter=12,
        leftIndent=0
    )
    
    header_style = ParagraphStyle(
        'Header',
        parent=styles['Normal'],
        fontSize=12,
        spaceAfter=20,
        alignment=1,  # Center
        textColor=HexColor('#6b7280')
    )
    
    # Build content
    story = []
    
    # Header
    story.append(Paragraph(f"Market Research Report: {product_name}", title_style))
    story.append(Paragraph(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", header_style))
    story.append(Paragraph("Powered by CirrusGo AI Market Research System", header_style))
    story.append(Spacer(1, 30))
    
    # Process content line by line
    lines = content.split('\n')
    for line in lines:
        line = line.strip()
        if not line:
            story.append(Spacer(1, 6))
            continue
            
        # Headers
        if line.startswith('# '):
            text = line[2:].strip()
            story.append(Paragraph(text, title_style))
        elif line.startswith('## '):
            text = line[3:].strip()
            story.append(Paragraph(text, subtitle_style))
        elif line.startswith('### '):
            text = line[4:].strip()
            story.append(Paragraph(f"<b>{text}</b>", body_style))
        elif line.startswith('- '):
            text = line[2:].strip()
            story.append(Paragraph(f"• {text}", body_style))
        elif line.startswith('**') and line.endswith('**'):
            text = line[2:-2].strip()
            story.append(Paragraph(f"<b>{text}</b>", body_style))
        else:
            # Regular text
            if line:
                story.append(Paragraph(line, body_style))
    
    # Footer
    story.append(Spacer(1, 30))
    story.append(Paragraph("Generated by CirrusGo AI Market Research System", header_style))
    story.append(Paragraph("Visit us at: https://cirrusgo.com", header_style))
    
    # Build PDF
    doc.build(story)
    return filename

@app.post("/api/analyze")
async def analyze_competitor(request: AnalysisRequest):
    """API endpoint for competitor analysis with agent caching"""
    try:
        if not request.product or not request.apiKey:
            return {"status": "failed", "error": "Product name and API key required"}
        
        # Clear expired cache entries periodically
        clear_expired_cache()
        
        # Dynamic import based on script selection
        script_mapping = {
            "market_research_simple": "market_research_simple",
            "market_research_mid": "market_research_mid", 
            "market_research_advanced": "market_research_advanced",
            "market_research_agent": "market_research_advanced"  # Default to advanced
        }
        
        script_name = script_mapping.get(request.script, "market_research_simple")
        
        print(f"📊 Starting analysis with {script_name} for: {request.product}")
        
        # Get or create cached system
        system = get_cached_system(script_name, request.apiKey)
        
        # Run analysis
        print(f"🔍 Running analysis for: {request.product}")
        results = system.analyze_competitor(request.product, request.industry, request.depth)
        
        # Extract clean content from results
        def get_clean_report(results):
            """Get clean report content from any result format"""
            if hasattr(results, 'output') and results.output:
                return extract_clean_markdown(results.output)
            elif hasattr(results, 'data') and results.data:
                return extract_clean_markdown(results.data)
            elif isinstance(results, dict):
                if "error" in results:
                    return f"Analysis Error: {results['error']}"
                if "report" in results:
                    return extract_clean_markdown(results["report"])
                return extract_clean_markdown(str(results))
            else:
                return extract_clean_markdown(str(results))
        
        clean_report = get_clean_report(results)
        
        print(f"✅ Analysis completed for: {request.product}")
        
        # Normalize the response format
        if isinstance(results, dict) and "error" in results:
            return {
                "status": "failed", 
                "error": results["error"],
                "product_name": request.product,
                "script_used": script_name
            }
        else:
            return {
                "status": "success",
                "product_name": request.product, 
                "report": clean_report,
                "script_used": script_name
            }
        
    except ImportError as e:
        return {"status": "failed", "error": f"Script '{request.script}' not found: {str(e)}"}
    except Exception as e:
        print(f"❌ API Error: {str(e)}")
        return {
            "status": "failed",
            "error": str(e),
            "product_name": request.product,
            "script_used": request.script
        }

@app.post("/api/cache/clear")
async def clear_cache():
    """Manually clear the agent cache"""
    try:
        global agent_cache, cache_expiry
        cleared_count = len(agent_cache)
        agent_cache.clear()
        cache_expiry.clear()
        print(f"🧹 Manually cleared {cleared_count} cached agents")
        return {
            "status": "success",
            "message": f"Cleared {cleared_count} cached agents"
        }
    except Exception as e:
        return {"status": "failed", "error": str(e)}

@app.get("/api/cache/status")
async def cache_status():
    """Get cache status information"""
    try:
        import time
        current_time = time.time()
        
        cache_info = []
        for key in agent_cache.keys():
            expiry_time = cache_expiry.get(key, 0)
            remaining_seconds = max(0, expiry_time - current_time)
            cache_info.append({
                "cache_key": key[:20] + "..." if len(key) > 20 else key,  # Truncate for privacy
                "remaining_seconds": int(remaining_seconds),
                "expires_in": f"{int(remaining_seconds // 60)}m {int(remaining_seconds % 60)}s" if remaining_seconds > 0 else "expired"
            })
        
        return {
            "status": "success",
            "cached_agents": len(agent_cache),
            "cache_duration_seconds": CACHE_DURATION,
            "cache_info": cache_info
        }
    except Exception as e:
        return {"status": "failed", "error": str(e)}

@app.post("/api/download/{format}")
async def download_report(format: str, request: DownloadRequest):
    """Download report in specified format"""
    try:
        # Generate clean report content
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Extract clean content using the same function as the main API
        raw_report = request.results.get('report', 'No analysis results available.')
        clean_content = extract_clean_markdown(raw_report)
        
        # Ensure we have good content
        if len(clean_content) < 50:
            clean_content = f"""# Market Research Analysis: {request.product}

## Analysis Summary
The analysis for {request.product} has been completed using the {request.results.get('script_used', 'default')} script.

## Results
{raw_report}

For more detailed analysis, please run the analysis again or contact support."""
        
        report_md = f"""# Market Research Report: {request.product}

**Generated:** {timestamp}  
**Powered by:** Cirrusgo AI Market Research System

---

{clean_content}

---

**Analysis Details:**
- Product Analyzed: {request.product}
- Status: {request.results.get('status', 'Unknown')}
- Script Used: {request.results.get('script_used', 'N/A')}

---
*Generated by Cirrusgo AI Market Research System*  
*Visit us at: https://cirrusgo.com*
"""
        
        if format == 'pdf':
            # Generate PDF using reportlab
            with tempfile.NamedTemporaryFile(delete=False, suffix='.pdf') as tmp_file:
                pdf_filename = create_pdf_report(clean_content, request.product, tmp_file.name)
                return FileResponse(
                    pdf_filename,
                    media_type='application/pdf',
                    filename=f"market_research_{request.product.replace(' ', '_')}.pdf"
                )
        
        elif format == 'markdown':
            with tempfile.NamedTemporaryFile(delete=False, suffix='.md', mode='w') as tmp_file:
                tmp_file.write(report_md)
                tmp_file.flush()
                return FileResponse(
                    tmp_file.name,
                    media_type='text/markdown',
                    filename=f"market_research_{request.product.replace(' ', '_')}.md"
                )
        
        else:
            raise HTTPException(status_code=400, detail="Invalid format. Use 'pdf' or 'markdown'")
            
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/")
async def root():
    """Root endpoint"""
    return {"message": "Market Research API", "docs": "/docs"}

@app.get("/api/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)